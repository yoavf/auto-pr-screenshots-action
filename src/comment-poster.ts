import * as github from '@actions/github';
import { commentLogger as logger } from './logger';
import type { Config, UploadedScreenshot } from './types';

interface CommentOptions {
  token: string;
  context: typeof github.context;
  config: Config;
  showAttribution: boolean;
}

const COMMENT_MARKER = '<!-- auto-pr-screenshots -->';

export async function postComment(
  screenshots: UploadedScreenshot[],
  options: CommentOptions,
): Promise<void> {
  const { token, context, config } = options;

  // Only post comments on pull requests
  if (context.eventName !== 'pull_request' || !context.payload.pull_request) {
    logger.warn('Not in a pull request context, skipping comment');
    return;
  }

  const octokit = github.getOctokit(token);
  const { owner, repo } = context.repo;
  const prNumber = context.payload.pull_request.number;

  logger.info(`ðŸ’¬ Posting comment to PR #${prNumber}`);

  try {
    // Find existing comment
    const { data: comments } = await octokit.rest.issues.listComments({
      owner,
      repo,
      issue_number: prNumber,
    });

    const existingComment = comments.find(
      (comment) => comment.body?.includes(COMMENT_MARKER) && comment.user?.type === 'Bot',
    );

    // Generate comment body
    const commentBody = generateCommentBody(screenshots, context, config, options.showAttribution);

    if (existingComment) {
      // Update existing comment
      await octokit.rest.issues.updateComment({
        owner,
        repo,
        comment_id: existingComment.id,
        body: commentBody,
      });
      logger.success('âœ… Updated existing comment');
    } else {
      // Create new comment
      await octokit.rest.issues.createComment({
        owner,
        repo,
        issue_number: prNumber,
        body: commentBody,
      });
      logger.success('âœ… Created new comment');
    }
  } catch (error) {
    logger.error('Failed to post comment:', error instanceof Error ? error.message : String(error));
    throw error;
  }
}

function generateCommentBody(
  screenshots: UploadedScreenshot[],
  context: typeof github.context,
  config: Config,
  showAttribution: boolean = false,
): string {
  const timestamp = new Date().toISOString();
  const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;

  let body = `${COMMENT_MARKER}\n`;
  body += '## ðŸ“¸ Auto PR Screenshots\n\n';
  body += `*Updated: ${timestamp}*\n\n`;

  if (screenshots.length === 0) {
    body += `âš ï¸ No screenshots were captured. Check the [action logs](${runUrl}) for details.\n`;
    return body;
  }

  // Group screenshots based on config
  if (config.output.comment.group_by === 'viewport') {
    const desktop = screenshots.filter((s) => s.name.includes('desktop'));
    const mobile = screenshots.filter((s) => s.name.includes('mobile'));
    const tablet = screenshots.filter((s) => s.name.includes('tablet'));
    const other = screenshots.filter(
      (s) =>
        !s.name.includes('desktop') && !s.name.includes('mobile') && !s.name.includes('tablet'),
    );

    if (desktop.length > 0) {
      body += '### ðŸ–¥ï¸ Desktop\n\n';
      body += generateScreenshotGrid(desktop, 3, 250, config);
    }

    if (tablet.length > 0) {
      body += '### ðŸ“± Tablet\n\n';
      body += generateScreenshotGrid(tablet, 4, 200, config);
    }

    if (mobile.length > 0) {
      body += '### ðŸ“± Mobile\n\n';
      body += generateScreenshotGrid(mobile, 5, 150, config);
    }

    if (other.length > 0) {
      body += '### ðŸ“¸ Other\n\n';
      body += generateScreenshotGrid(other, 4, 200, config);
    }
  } else {
    // Default: show all screenshots in a grid
    body += generateScreenshotGrid(screenshots, 4, 200, config);
  }

  // Add metadata
  body += '\n---\n';
  body += '<details>\n<summary>ðŸ“‹ Screenshot Details</summary>\n\n';
  body += '| Name | Browser | Link |\n';
  body += '|------|---------|------|\n';

  for (const screenshot of screenshots) {
    const name = formatScreenshotName(screenshot.name);
    body += `| ${name} | ${screenshot.browser} | [View](${screenshot.url}) |\n`;
  }

  body += '\n</details>\n\n';

  if (showAttribution) {
    body += `*Generated by [Auto PR Screenshots](https://github.com/yoavf/auto-pr-screenshots-action) â€¢ [View Run](${runUrl})*`;
  }

  return body;
}

function generateScreenshotGrid(
  screenshots: UploadedScreenshot[],
  columns: number,
  width: number,
  config: Config,
): string {
  let grid = '<table>\n';

  for (let i = 0; i < screenshots.length; i += columns) {
    grid += '<tr>\n';

    for (let j = 0; j < columns && i + j < screenshots.length; j++) {
      const screenshot = screenshots[i + j];
      const name = formatScreenshotName(screenshot.name);

      // Find the corresponding config for this screenshot to get steps
      const screenshotConfig = config.screenshots.find((sc) => sc.name === screenshot.name);

      grid += '<td align="center">\n';
      grid += `<b>${name}</b><br>\n`;
      grid += `<a href="${screenshot.url}" target="_blank">\n`;
      grid += `<img src="${screenshot.url}" alt="${name}" width="${width}">\n`;
      grid += '</a>\n';

      if (screenshot.browser !== 'chromium') {
        grid += `<br><sub>${screenshot.browser}</sub>\n`;
      }

      // Add playwright actions if they exist
      if (screenshotConfig?.steps && screenshotConfig.steps.length > 0) {
        grid += '<br>\n';
        grid += '<details>\n';
        grid += '<summary><sub>ðŸŽ­ Actions</sub></summary>\n';
        grid += '<div align="left">\n';
        grid += '<br>\n';

        for (const step of screenshotConfig.steps) {
          if (step.click) {
            grid += `<code>click("${step.click}")</code><br>\n`;
          }
          if (step.fill) {
            grid += `<code>fill("${step.fill.selector}", "${step.fill.text}")</code><br>\n`;
          }
          if (step.wait) {
            grid += `<code>wait(${step.wait}ms)</code><br>\n`;
          }
          if (step.waitFor) {
            grid += `<code>waitFor("${step.waitFor}")</code><br>\n`;
          }
        }

        grid += '</div>\n';
        grid += '</details>\n';
      }

      grid += '</td>\n';
    }

    // Fill empty cells if needed
    const emptyCells = columns - (screenshots.length - i);
    if (emptyCells > 0 && emptyCells < columns) {
      for (let k = 0; k < emptyCells; k++) {
        grid += '<td></td>\n';
      }
    }

    grid += '</tr>\n';
  }

  grid += '</table>\n\n';
  return grid;
}

function formatScreenshotName(name: string): string {
  let formattedName = name;

  // Remove file extension
  formattedName = formattedName.replace(/\.(png|jpg|jpeg)$/i, '');

  // Remove browser suffix
  formattedName = formattedName.replace(/-(chromium|firefox|webkit)$/i, '');

  // Convert kebab-case to Title Case
  return formattedName
    .split('-')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}
